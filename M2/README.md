# M2: 打印进程树 (pstree)

## 实验描述

🗒️**实验要求：实现 pstree 打印进程之间的树状的父子关系**

Linux 系统中可以同时运行多个程序。运行的程序称为**进程**。除了所有进程的根之外，每个进程都有它唯一的父进程，你的任务就是把这棵树在命令行中输出。你可以自由选择展示树的方式 (例如使用缩进表示父子关系)。

Linux 系统中有 `pstree` 命令，进程树会以非常漂亮的格式排版 (每个进程的第一个孩子都与它处在同一行，之后的孩子保持相同的缩进)：

```text
systemd─┬─accounts-daemon─┬─{gdbus}
        │                 └─{gmain}
        ├─acpid
        ├─agetty
        ├─atd
        ├─cron
        ├─dbus-daemon
        ├─dhclient
        ├─2*[iscsid]
        ├─lvmetad
        ├─lxcfs───10*[{lxcfs}]
        ├─mdadm
        ├─polkitd─┬─{gdbus}
        │         └─{gmain}
        ├─rsyslogd─┬─{in:imklog}
        │          ├─{in:imuxsock}
        │          └─{rs:main Q:Reg}
        ...
```

## 功能要求

- 读取系统进程信息
- 构建进程树结构
- 以树状格式输出（支持缩进或图形化显示）
- 显示进程名称和PID
- 支持命令行选项


## 使用示例

```bash
cd pstree
go build
./pstree
./pstree -p
./pstree -n
./pstree -p -n
```

## 参考资料

Linux 内核文档 (`man proc`)，字段按空格分隔，对应的含义如下：

| 索引 | 值              | 字段名      | 解释                                                         |
| :--- | :-------------- | :---------- | :----------------------------------------------------------- |
| 1    | **10**          | pid         | **进程 ID**。                                                |
| 2    | **(rcu_sched)** | comm        | **应用程序名称**。括号内的字符串是该任务的名称。`rcu_sched` 是 Linux 内核的一个核心机制（Read-Copy-Update scheduler），用于处理并发数据的同步。 |
| 3    | **I**           | state       | **进程状态**。`I` 代表 **Idle** (空闲的内核线程)。这通常意味着它是一个内核线程，当前处于不消耗 CPU 的休眠状态，等待被唤醒。 |
| 4    | **2**           | ppid        | **父进程 ID**。PID 2 通常是 `kthreadd`，它负责管理所有内核线程。 |
| 5    | **0**           | pgrp        | **进程组 ID**。                                              |
| 6    | **0**           | session     | **会话 ID**。                                                |
| 7    | **0**           | tty_nr      | **控制终端**。0 表示该进程没有关联的终端（内核线程通常都没有）。 |
| 8    | **-1**          | tpgid       | 控制终端进程组 ID。-1 表示没有。                             |
| 9    | **2129984**     | flags       | **内核标志**。表示进程特性的位掩码（例如 `PF_KTHREAD` 表示它是内核线程）。 |
| 10   | **0**           | minflt      | 次要缺页错误次数（Minor page faults）。                      |
| 11   | **0**           | cminflt     | 子进程的次要缺页错误次数。                                   |
| 12   | **0**           | majflt      | 主要缺页错误次数（Major page faults，需要读磁盘）。          |
| 13   | **0**           | cmajflt     | 子进程的主要缺页错误次数。                                   |
| 14   | **0**           | utime       | **用户态 CPU 时间**。单位是 jiffies（时钟滴答）。因为是内核线程，所以为 0。 |
| 15   | **843500**      | stime       | **内核态 CPU 时间**。单位是 jiffies。这意味着该进程自启动以来，在内核模式下运行了相当长的时间（具体秒数取决于系统的 `USER_HZ`，通常是 100）。 |
| 16   | **0**           | cutime      | 等待子进程的用户态时间。                                     |
| 17   | **0**           | cstime      | 等待子进程的内核态时间。                                     |
| 18   | **20**          | priority    | **动态优先级**。标准值为 20。                                |
| 19   | **0**           | nice        | **Nice 值**。0 表示标准优先级。                              |
| 20   | **1**           | num_threads | **线程数**。该进程包含的线程数量。                           |
| 21   | **0**           | itrealvalue | 下一次 SIGALRM 发送前的间隔（通常用于计时器）。              |
| 22   | **20**          | starttime   | **启动时间**。进程在系统启动后多久开始运行的（单位 jiffies）。值很小 (20)，说明它是随系统启动几乎立即启动的。 |
| 23   | **0**           | vsize       | **虚拟内存大小**。内核线程通常显示为 0，因为它们共享内核空间。 |
| 24   | **0**           | rss         | **常驻内存集 (Resident Set Size)**。内核线程不使用用户空间页面，所以为 0。 |
| 25   | **18446...**    | rsslim      | RSS 限制。这个巨大的数字是 `unsigned long` 的最大值，表示没有限制。 |

*(注：后面的数字大多为 0 或特定的内存地址/信号位图，对于常规分析通常不太重要)*