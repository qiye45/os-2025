# M9: 崩溃一致性 KV 数据库 (libkvdb)

## 实验背景

现代操作系统和应用程序广泛依赖于高效、可靠的持久化存储。无论是配置管理、缓存、元数据存储还是日志系统，Key-Value 数据库 (KVDB) 都是最常见的底层组件之一。相比传统的关系型数据库，KVDB 结构简单、易于嵌入、性能优越，广泛应用于嵌入式系统、浏览器、移动设备等场景。

数据库为我们提供了 ACID (Atomicity, Consistency, Isolation, Durability) 的保证。其中，**崩溃一致性 (crash consistency)** 是持久化存储系统设计中的一大挑战。系统在任意时刻可能因断电、内核 panic、kill -9 等原因崩溃，重启后必须保证数据不会损坏、不会丢失已提交的操作，也不会出现 "部分写入" 导致的不可恢复状态。

在这个实验中，你将实现一个具备崩溃一致性的嵌入式 Key-Value 数据库库 (libkvdb)，并借此机会理解 "persistence" 这一操作系统领域的核心问题。

## 实验描述

实现一个简单的 Key-Value 数据库库 (libkvdb)，支持基本的 put、get 操作，并保证在任意时刻崩溃后，数据库能够恢复到一致的状态。**性能不是本实验的重点，正确性和 crash consistency 优先。**

## API 规范

### 数据结构

```c
struct kvdb_t {
    const char *path;  // 数据库文件路径
    int fd;            // 文件描述符
    // 可以根据需要添加其他字段
};
```

### 接口函数

#### `int kvdb_open(struct kvdb_t *db, const char *path)`

**功能：** 初始化数据库，将数据库文件与 db 结构体关联。path 为数据库文件路径。如果路径不存在，则创建一个空数据库。

**参数：**
- `db`: 指向 [`kvdb_t`](c_version/kvdb.h:5) 结构体的指针
- `path`: 数据库文件路径

**返回值：** 成功返回 0，失败返回 -1

---

#### `int kvdb_put(struct kvdb_t *db, const char *key, const char *value)`

**功能：** 将 key 对应的值设置为 value。如果 key 已存在，则覆盖原有值。

**参数：**
- `db`: 指向 [`kvdb_t`](c_version/kvdb.h:5) 结构体的指针
- `key`: 键（字符串）
- `value`: 值（字符串）

**返回值：** 成功返回 0，失败返回 -1

---

#### `int kvdb_get(struct kvdb_t *db, const char *key, char *buf, size_t length)`

**功能：** 查找 key 对应的值，并将其拷贝到 buf，最多拷贝 length-1 字节，并以 `\0` 结尾。

**参数：**
- `db`: 指向 [`kvdb_t`](c_version/kvdb.h:5) 结构体的指针
- `key`: 键（字符串）
- `buf`: 用于存储值的缓冲区
- `length`: 缓冲区大小

**返回值：** 找到则返回实际拷贝的字节数（不含结尾的 `\0`），未找到返回 -1

---

#### `int kvdb_close(struct kvdb_t *db)`

**功能：** 关闭数据库，释放相关资源。

**参数：**
- `db`: 指向 [`kvdb_t`](c_version/kvdb.h:5) 结构体的指针

**返回值：** 成功返回 0，失败返回 -1

## 安全性要求

你需要满足以下两方面的安全性：

### 1. 进程安全、线程安全

- 允许多个进程中的多个线程同时打开同一个 Key-value database
- 支持在很长的一段时间内并发访问
- 一个进程（线程）写入的 key 可以被另外的进程（线程）读到

### 2. 崩溃一致性

- `write` 系统调用不能保证数据的完整性（写入的数据可能只有部分落盘）
- 需要使用适当的同步机制（如 `fsync`、`fdatasync`、`msync` 等）保证数据持久化
- 系统在任意时刻崩溃后，数据库必须能够恢复到一致的状态

## 正确性标准

假设我们能够 "观察到" 系统内所有进程和线程对同一个 kvdb 的访问，则所有操作应满足**可序列化（serializable）**要求：即所有 put 和 get 操作可以排列为某个全局顺序 O，满足以下条件：

### 1. 最近写可见性

对每一个 key 的 get 操作，总是返回在全局顺序 O 中该 get 之前最近一次 put 所写入的值；如果不存在对应的 put，应返回 -1。

### 2. 顺序一致性

对于具有 happens-before 关系的任意两次操作（如同一线程内，操作 a 发生在操作 b 之前），它们在全局顺序 O 中也必须保持 a 在 b 之前。

### 3. 并发一致性

对于没有 happens-before 关系的两次并发操作（例如并发地对同一 key 的两次 put），所有发生在这两次操作之后的 get 操作，必须返回相同的值（即，系统需表现为选定其中一个 put 的效果为最终结果）。