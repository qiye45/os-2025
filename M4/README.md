# M4: C 语言 REPL (crepl)

## 1. 实验概述

实现一个 C 语言的 Read-Eval-Print-Loop (REPL)，支持交互式执行 C 代码。这是一个动态编译和加载的实验，展示了 JIT (Just-In-Time) 编译技术的基本原理。

## 2. 实验描述

### 2.1 基本功能

`crepl` - 逐行从 stdin 中输入，根据内容进行处理：

- **函数定义**：如果输入的一行定义了一个函数，则把函数编译并加载到进程的地址空间中
- **表达式求值**：如果输入是一个表达式，则把它的值输出（在读取到表达式后立即输出结果，并 `fflush(stdout)` 确保结果立即可见）

### 2.2 总览

```
crepl
```

### 2.3 详细描述

解释执行每一行标准输入中的 C "单行" 代码（假设我们只使用 `int` 类型，即所有输入的表达式都是整数；定义函数的返回值也永远是整数），分如下两种情况：

#### 函数定义

函数总是以 `int` 开头，接收若干 `int` 类型的参数，返回一个 `int` 数值，例如：

```c
int fib(int n) { if (n <= 1) return 1; return fib(n - 1) + fib(n - 2); }
```

#### 表达式求值

如果一行不是以 `int` 开头，我们认为这一行是一个 C 语言的表达式，其类型为 `int`，例如：

```c
1 + 2 || (fib(3) * fib(4))
```

### 2.4 实现要求

- 函数经过 gcc 编译，并被加载到当前进程的地址空间中
- 函数可以引用之前定义过的函数
- 函数和表达式均可以调用之前定义过的函数
- **不允许**访问全局的状态（变量）或调用标准 C 中的函数
- 如果一行既不是合法的函数也不是合法的表达式，crepl 可以不保证执行结果（不一定要报告错误，但程序要尽量不会 crash）
- 重复定义重名函数可以当做 undefined behavior 不必做出过多处理

### 2.5 使用示例

```
$ ./crepl
>> int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } ↵
OK.
>> gcd(256, 144) * gcd(56, 84) ↵
= 448.
```

## 3. 正确性标准

### 3.1 基本要求

- 正确解析单行的函数（以 `int` 开头）
- 默认其他输入都是表达式
- 对于不合法的 C 代码（例如不合法的表达式），程序应该给出错误提示而不应该 crash

### 3.2 注意事项

- 允许函数和表达式调用之前（在 crepl 中）定义过的函数
- 可以假设输入的命令/表达式数量不超过 100 个
- 运行目录可能没有写入权限，建议将创建的临时文件都放在 `/tmp/` 目录下
- 建议使用 `mkstemp` family API 创建临时文件
- 主进程确实求出了所有表达式的值

### 3.3 限制条件

⚠️ **禁止使用 `system()` 和 `popen()`**

调用它们将会导致编译错误。允许使用 exec family 的系统调用：
- `execl`
- `execlp`
- `execle`
- `execv`
- `execvp`
- `execvpe`