# M3: 系统调用性能分析器 (sperf)

## 1. 背景

"Everything is a state machine." 能够帮助我们解析 "状态机执行" 的工具，自然对调试、性能诊断等任务是至关重要的。我们在课堂上展示过各类分析状态机执行轨迹的工具，包括 **gdb (step/stepi)、strace** 等。为了加深大家对这些工具的认识，我们使用课堂上学过的进程管理 API，去启动一个这样的工具，并获得它们的输出。这个实验也替代了通常《操作系统》课程中常见的管道 (shell) 作业。

## 2. 实验描述

🗒️**实验要求：实现系统调用 Profiler**

实现一个命令行工具，它能启动另一个程序，并统计该程序中各个系统调用的占用时间。对于较短时间运行的程序，你可以一次性打印出耗时最多的几个系统调用。对于耗时较长的程序，你需要保证每秒大约**打印 10 次** (不要过多) 系统调用的耗时信息。

### 2.1 总览

```
sperf COMMAND [ARG]...
```

### 2.2 描述

它会运行 COMMAND 命令 (如果 COMMAND 是以 `/` 开头的绝对路径，则直接执行；否则在 `PATH` 环境变量中搜索到第一个存在且可执行的文件)，并为 COMMAND 传入 ARG 参数 (列表)，然后统计命令执行的系统调用所占的时间。例如执行 `sperf find /` 会在系统中执行 `find /`，并且在屏幕上显示出耗时最多的若干系统调用的时间。

sperf 假设 `COMMAND` 是单进程、单线程的，无需处理多进程和多线程的情况。

⚠️**只能使用 execve**

为了强迫大家理解 execve 系统调用，sperf 实现时，**只能使用 execve 系统调用**；使用 glibc 对 execve 的包装 (execl, execlp, execle, execv, execvp, execvpe) 将导致编译错误。在实际编程中，exec 系列函数，例如以 p (path) 结尾的函数会从 PATH 环境变量中搜索可执行文件。

### 2.3 解释

你可以以任何方式输出系统调用花费的时间，例如你可以每隔一段时间把输出到标准输出：

```
$ ./sperf-64 tree /
Time: 0.1s
lstat (50%)
getdents (20%)
...
====================
Time: 0.2s
lstat (50%)
getdents (20%)
...
```

在我们的参考实现中，通过在字符终端里绘制系统调用图的方式展示系统调用的耗时 (系统调用所花时间与所占面积成正比)。你完全可以把你的 sperf 的输出管道给另一个 "可视化" 工具来生成它——这与本次实验无关。

![img](https://jyywiki.cn/OS/img/sperf-demo.gif)

但无论如何，一个可视化的工具都可以帮我们提供关于系统和程序运行的有效信息，例如：

- 对于 memory intensive 的纯计算型程序，brk 和 munmap 花去了最多的时间；
- 对于文件系统遍历，文件系统元数据访问 lstat 和 getdents 花去了最多的时间。

## 3. 正确性标准

sperf 对 profiling 结果的输出格式没有特别要求，并假设被 trace 的程序是单进程程序 (Online Judge 测试用例会保证这一点)。如果进程没有发生系统调用，或系统调用耗时很长没有结束 (例如等待输入的 `read` 或大量数据的写入)，你相应的信息也可以不必更新 (即遇到很长的系统调用时，你不需要立即将这个系统调用的时间统计进来，可以等它执行结束后再统计)。

为了 Online Judge 判定方便，我们要求你的程序满足以下输出格式：

🗒️**输出格式要求**

每次输出耗时 top 5 的系统调用、每个系统调用至多输出一次，包括系统调用的小写名字 (strace 输出的名字)和系统调用耗时比例按照 "`(XX%)`"。使用

```c
printf("%s (%d%%)\n", syscall_name, ratio);
```

输出即可。在每次统计信息输出完毕后，打印 80 个 `\0` (注意不是 `'0'`，是数值为 0 的字符，它们不会在终端上显示)。我们将以这 80 个 `\0` 作为划分。

## 4. 功能要求

- 启动并追踪目标程序
- 统计各系统调用的执行时间
- 短时程序：一次性输出统计结果
- 长时程序：每秒打印约10次更新
- 按耗时排序显示 Top 5 系统调用

## 5. 使用示例

```bash
# 基本用法
sperf COMMAND [ARG]...

# 示例
./sperf ls -la
./sperf find /
./sperf tree /
./sperf ./long-running-program
```
